
/*

GlueJS provides an integrated event and function handler across multiple devices and client-server-client environments.

GlueServer - Version 0.1.1 (beta).
Developed by Luke Cohen.

*/

'use strict';

var GlueServer = function() {


  /* internal variables and objects */

  this.allowedServerFunctions = [];
  this.allowedFunctions = {};
  this.allowedServerEvents = [];
  this.allowedEvents = {};
  this.allowedObjects = {};
  this.subscribedClients = {};
  this.objects = [];
  this.sessionKey = "";
  this.sha1 = "";

  var cons = true;

  /* / */


  /* gets the object ready to receive events & functions */
  this.init = function() {
    cons && console.log('init');

    /* create a unique key for this session */
    this.sessionKey = generateUUID();
    return true;

  };


  /* fetches the latest version of an allowed object */
  this.fetchObject = function(objectName) {
    cons && console.log('fetchObject', objectName);

    if (this.allowedObjects[objectName]) {

      var objectNameHash = this.sha1(objectName);
      var theObject = this.objects[objectNameHash];

      cons && console.log("theObject in memory", theObject);

      if (theObject.length == 0) {
        theObject = "{}";
      }

      if (typeof theObject !== 'object') {
        theObject = JSON.parse(theObject, null, 2);
      }

      return theObject;

    } else {
      return false;
    }

  };


  /* notifies an append to an object */
  this.broadcastAppend = function(objectName, objectAddition, ioObj, socketObj) {
    cons && console.log('broadcastAppend', objectName, objectAddition);

    var msg = {
      "messageType" : "objectAppend",
      "objectName" : objectName,
      "objectAddition" : objectAddition
    };

    socketObj.broadcast.emit('glue message', msg);
    socketObj.emit('glue message', msg);

  };


  /* notifies an object splice */
  this.broadcastSplice = function(objectName, spliceIndex, spliceHowMany, ioObj, socketObj) {
    cons && console.log('broadcastSplice', objectName, spliceIndex, spliceHowMany);

    var msg = {
      "messageType" : "objectSplice",
      "spliceIndex" : spliceIndex,
      "spliceHowMany" : spliceHowMany
    };

    socketObj.broadcast.emit('glue message', msg);
    socketObj.emit('glue message', msg);

  };


  /* lets all connected clients know when an object has been updated */
  this.broadcastObjectUpdate = function(objectName, ioObj, socketObj) {
    cons && console.log('broadcastObjectUpdate', objectName);

    if (this.allowedObjects[objectName]) {

      var objectNameHash = this.sha1(objectName);
      var theObject = this.objects[objectNameHash];
      theObject = JSON.parse(theObject);

      var msg = {
        "messageType": "objectUpdate",
        "objectName": objectName,
        "newObject": theObject
      };

      msg.object = theObject;

      socketObj.broadcast.emit('glue message', msg);
      socketObj.emit('glue message', msg);

    } else {
      return false;
    }

  };


  /* broadcasts an update notification on a specific object node */
  this.broadcastObjectNodeUpdate = function(objectName, nodeIndex, ioObj, socketObj) {
    cons && console.log('broadcastObjectNodeUpdate', objectName, nodeIndex);

    if (this.allowedObjects[objectName]) {

      var objectNameHash = this.sha1(objectName);
      var updatedNode = this.objects[objectNameHash][nodeIndex];

      var msg = {
        "messageType": "objectNodeUpdate",
        "objectName": objectName,
        "nodeIndex": nodeIndex
      };

      msg.updatedNodeObject = updatedNode;

      socketObj.broadcast.emit('glue message', msg);
      socketObj.emit('glue message', msg);

    } else {
      return false;
    }

  };


  /* 'objectSplice' simulates the .splice() function, cutting up the object as requested */
  this.objectSplice = function(objectName, index, howmany) {
    cons && console.log('objectSplice', index, howmany);

    if (this.allowedObjects[objectName]) {

      var obj = this.allowedObjects[objectName];
      var objectNameHash = this.sha1(objectName);

      if (obj.objectRW === false) {

        var theObject = this.objects[objectNameHash];
        theObject.splice(objectToAppend, index, howmany);

        this.objects[objectNameHash] = theObject;

      } else {
        console.log('object is read-only');
        return false;
      }

    } else {
      return false;
    }

  };


  /* 'listAppend' is a simpler version of objectAppend - where the object we're appending to is a flat JSON list rather than an object containing objects */
  this.listAppend = function(objectName, itemToAppend) {
    cons && console.log('listAppend', objectName, itemToAppend);

  }


  /* 'objectAppend' simulates the .push() function, adding an object an existing object */
  this.objectAppend = function(objectName, objectToAppend) {
    cons && console.log('objectAppend', objectName, objectToAppend);

    var obj = this.allowedObjects[objectName];
    var objectNameHash = this.sha1(objectName);
    var curObject = this.objects[objectNameHash];

    if (obj && obj.objectRW === false) {

      cons && console.log("object before append", curObject);


      if (typeof curObject === 'string') {
        curObject = JSON.parse(curObject);
      }


      /* generate GUID for this new object */
      var newObjGUID = generateUUID();
      objectToAppend._glueGUID = newObjGUID;


      /* add new object to end of existing object */
      if (!Object.keys(curObject).length) {
        curObject[0] = objectToAppend;
      } else {
        curObject[Object.keys(curObject).length] = objectToAppend;
        this.objects[objectNameHash] = curObject;
      }


      cons && console.log("object after append", this.objects[objectNameHash]);
      return true;

    } else {

      return false;

    }

  };


  /* updates the object, if it isn't read-only */
  this.updateObject = function(objectName, newObject) {
    cons && console.log('updateObject', objectName, newObject);

    if (this.allowedObjects[objectName]) {

      var obj = this.allowedObjects[objectName];
      var objectNameHash = this.sha1(objectName);

      if (obj.objectRW === false) {

        this.objects[objectNameHash] = newObject;
        return true;

      } else {
        cons && console.log('object is read-only');
        return false;
      }

    } else {
      cons && console.log("object not registered on server");
      return false;
    }

  }


  /* updates a specific node in an object */
  this.updateObjectNode = function(objectName, nodeIndex, newObject) {
    cons && console.log("updateObjectNode", objectName, nodeIndex, newObject);

    var objectNameHash = this.sha1(objectName);

    if (this.allowedObjects[objectName] && this.objects[objectNameHash][nodeIndex] && this.allowedObjects[objectName].objectRW === false) {

      cons && console.log("changing object (" + objectName + ") node (" + nodeIndex + ") to", newObject);

      if (checkStringJSON(newObject) === true) {
        newObject = JSON.parse(newObject);
      }

      this.objects[objectNameHash][nodeIndex] = newObject;

      cons && console.log(objectName + " -> " + nodeIndex + " after update", this.objects[objectNameHash][nodeIndex]);
      cons && console.log(objectName + " after update " + this.objects[objectNameHash]);

      return true;

    } else {
      return false;
    }

  };


  /* creates a lock on an object if it isn't already locked */
  this.lockObject = function(objectName) {
    cons && console.log("lockObject", objectName);

    if (isRelName(objectName) && this.allowedObjects[objectName]) {

      var obj = this.allowedObjects[objectName];

      if (obj.locked === true) {

        var msg = {
          "messageType": "lockFail",
          "objectName": objectName
        };

        socketObj.emit('glue message', msg);

        return false;

      } else {

        var newLockToken = generateUUID();

        obj.locked = true;
        obj.lockToken = newLockToken;

        var msg = {
          "messageType": "lockSuccess",
          "objectName": objectName,
          "lockToken": newLockToken
        };

        socketObj.emit('glue message', msg);

        return true;

      }

    } else {
      return false;
    }

  }
  /* / */


  /* release an object lock, if the lockToken provided is associated with a lock */
  var unlockObject = function(objectName, lockToken) {
    cons && console.log("unlockObject", objectName, lockToken);



  }
  /* / */


  /* adds an object to the allowedObjects list */
  this.registerAllowedObject = function(objectName, readWriteOnly) {
    cons && console.log('registerAllowedObject', objectName, readWriteOnly);

    if (!this.allowedObjects[objectName]) {

      var newObject = {};
      var objectNameHash = this.sha1(objectName);

      newObject.objectRW = readWriteOnly;
      this.allowedObjects[objectName] = newObject;

      var newObj = [];
      this.objects[objectNameHash] = newObj;

    }

  };


  /* de-registers an allowed object */
  this.deRegisterAllowedObject = function(objectName) {
    cons && console.log('deRegisterAllowedObject', objectName);

    if (allowedObjects.indexOf(objectName) > -1) {
      allowedObjects.splice(allowedObjects.indexOf(objectName));
    }

  };


  /* return allowedFunctions */
  this.listAllowedFunctions = function(remoteOrGeneral) {
    cons && console.log('listAllowedFunctions', remoteOrGeneral);

    switch(remoteOrGeneral) {
      case "remote":
        return this.allowedServerFunctions;
      break;

      case "general":
        return this.allowedFunctions;
      break;
    }

  };


  /* adds a function to the allowedFunctions or allowedRemoteFunctions list */
  this.registerAllowedFunction = function(functionName, remoteOrGeneral) {
    cons && console.log('registerAllowedFunction', functionName, remoteOrGeneral);

    switch(remoteOrGeneral) {

      case "general":

        if (!this.allowedFunctions[functionName]) {
          this.allowedFunctions[functionName] = {};
        }

      break;

      case "remote":

        if (!this.allowedServerFunctions[functionName]) {
          this.allowedServerFunctions[functionName] = {};
        }

      break;

    }

  };


  /* removes a function from the allowedFunctions or allowedRemoteFunctions list */
  this.deregisterAllowedFunction = function(functionName, remoteOrGeneral) {
    cons && console.log('deregisterAllowedFunction', functionName, remoteOrGeneral);

    switch(remoteOrGeneral) {

      case "general":

        if (allowedFunctions.indexOf(functionName) > -1) {
          allowedFunctions.splice(index, 1);
        }

      break;

      case "remote":

        if (allowedServerFunctions.indexOf(functionName) > -1) {
          allowedRemoteFunctions.splice(index, 1);
        }

      break;

    }

  };


  /* adds an event to the allowedEvents or allowedServerEvents list */
  this.registerAllowedEvent = function(eventName, remoteOrGeneral) {
    cons && console.log('registerAllowedEvent', eventName, remoteOrGeneral);

    switch(remoteOrGeneral) {

      case "general":

        if (!this.allowedEvents[eventName]) {
          this.allowedEvents[eventName] = {};
        }

      break;

      case "remote":

        if (!this.allowedServerEvents[eventName]) {
          this.allowedServerEvents[eventName] = {};
        }

      break;

    }

  };


  /* removes an event from the allowedEvents or allowedServerEvents list */
  this.deregisterAllowedEvent = function(eventName, remoteOrGeneral) {
    cons && console.log('deregisterAllowedEvent', eventName, remoteOrGeneral);

    switch(remoteOrGeneral) {

      case "general":

        if (allowedEvents.indexOf(eventName) > -1) {
          allowedEvents.splice(index, 1);
        }

      break;

      case "remote":

        if (allowedServerEvents.indexOf(eventName) > -1) {
          allowedServerEvents.splice(index, 1);
        }

      break;

    }

  };


  /* registers a new place */
  this.registerPlace = function(place) {
    cons && console.log('registerPlace', place);

    var newPlace = {};
    newPlace.key = place.key;

    if (place) {

      places.push(newPlace);
      return true;

    } else {

      return false;

    }

  };


  /* triggers an event to all subscribed places */
  this.triggerEvent = function(eventName, eventParameters) {
    cons && console.log('dispatchEvent', eventName, eventParameters);

    if (eventName) {

      var newEvent = {};
      newEvent.eventName = eventName;
      newEvent.eventParameters = eventParameters;

      /*socket.emit(
        'new message', {
          'message' : {
            'messageType' : 'ilSignal',
            'messageSubtype' : 'ilGeneralEvent',
            'sessionID' : key,
            'event' : newEvent
          }
        }
      );*/

    }

  };


  /* dispatches a function request to all registered places */
  this.dispatchFunction = function(functionName, functionParameters) {
    cons && console.log('dispatchFunction', functionName, functionParameters);

    if (functionName) {

      var newFunction = {};
      newFunction.functionName = functionName;
      newFunction.functionParameters = functionParameters;

      /*socket.emit(
        'new message', {
          'message' : {
            'messageType' : 'ilSignal',
            'messageSubtype' : 'ilGeneralFunction',
            'sessionID' : key,
            'function' : newFunction
          }
        }
      );*/

    }

  };


  /* dispatches a function here (i.e on the server) */
  this.dispatchHere = function(fn, args, callbackFunction) {
    cons && console.log('dispatchHere', fn, args, callbackFunction);

    fn = (typeof fn == "function") ? fn : global[fn];
    return global[fn].apply(this, args || []);

    //callbackFunction(fn.apply(this, args || []));

  };


  /* generate error message JSON */
  this.errorMessage = function(errorMessage) {

    var msg = {
      "messageType" : "error",
      "errorMessage" : errorMessage
    };

    return msg;

  };


  /* triggers relevant functions depending on the socket message received */
  this.signalHandler = function(message, ioObj, socketObj) {
    cons && console.log("signalHandler", message);

    message = JSON.parse(message);

    switch(message.messageType) {


      case 'functionServer':
        this.glueFunctionServer(message.function);
      break;


      case 'triggerEvent':

        var eventName = message.eventName;
        var eventParams = message.eventParams;

        if (this.allowedEvents[triggerName]) {

          var msg = {
            "messageType": "eventTriggered",
            "eventName": eventName,
            "eventParams": eventParams
          };

          socketObj.broadcast.emit('glue message', msg);
          socketObj.emit('glue message', msg);

        } else {

          var msg = this.errorMessage("event not registered at server");
          socketObj.emit('glue message', msg);
          return false;

        }

      break;


      case 'triggerFunction':

        var functionName = message.functionName;
        var functionParams = message.functionParams;

        /* TODO: run the function here on the server first, if it exists */

        if (this.allowedFunctions[functionName]) {

          var msg = {
            "messageType" : "functionTriggered",
            "functionName" : functionName,
            "functionParams" : functionParams
          };

          socketObj.broadcast.emit('glue message', msg);
          socketObj.emit('glue message', msg);

        } else {

          var msg = this.errorMessage("function not registered at server");
          socketObj.emit('glue message', msg);
          return false;

        }

      break;


      case 'fetchObject':

        var objectName = message.object.objectName;
        var objectNameHash = this.sha1(objectName);
        var fetchedObject = this.fetchObject(objectName);

        var newObject = {};
        newObject[objectName] = fetchedObject;

        var msg = {
          "messageType" : "loadedObject",
          "responseLength" : 0,
          "objectName" : objectName
        };

        var objToReturn = this.fetchObject(objectName);

        msg.object = objToReturn;
        cons && console.log("object to return", objToReturn);

        socketObj.emit('glue message', msg);

      break;


      case 'objectAppend':

        var objectName = message.object.objectName;
        var objectAddition = message.objectAddition;

        if (this.objectAppend(objectName, objectAddition) === true) {
          this.broadcastAppend(objectName, objectAddition, ioObj, socketObj);
        }

      break;


      case "objectItemDelete":

        var objectName = message.objectName;
        var itemToDelete = message.itemToDelete;
        var isIndex = message.isIndex;

        var obj = this.fetchObject(objectName);

        if (obj[itemToDelete]) {
          delete obj[itemToDelete];
        }

        this.updateObject(objectName, obj);

        var msg = {
          "messageType" : "objectItemDelete",
          "objectName" : objectName,
          "itemToDelete" : itemToDelete,
          "isIndex" : isIndex
        };

        msg.itemToDelete = itemToDelete;

        socketObj.broadcast.emit('glue message', msg);
        socketObj.emit('glue message', msg);

      break;


      case 'updateObject':

        var objectName = message.objectName;
        var newObject = message.newObject;

        if (this.updateObject(objectName, newObject) === true) {
          this.broadcastObjectUpdate(objectName, ioObj, socketObj);
        }

      break;


      case 'updateObjectNode':

        var objectName = message.objectName;
        var nodeIndex = message.nodeIndex;
        var newObject = message.newObject;

        if (isRelName(objectName) && typeof nodeIndex === 'number' && isRelObject(newObject)) {

          if (this.updateObjectNode(objectName, nodeIndex, newObject) === true) {
            this.broadcastObjectNodeUpdate(objectName, nodeIndex, ioObj, socketObj);
          }

        } else {
          return false;
        }

      break;


      case 'lockRequest':

        var objectName = message.objectName;
        this.lockObject(objectName);

      break;


      case 'lockRelease':

        var objectName = message.objectName;
        var lockToken = message.lockToken;

        this.unlockObject(objectName, lockToken);

      break;


    }

  };


  /* listen for functions */
  var glueFunction = function(theFunction) {
    cons && console.log('glueFunction', theFunction);

    var functionName = theFunction.functionName;
    var functionParams = theFunction.functionParams;

    if (this.allowedFunctions.indexOf(functionName) > -1) {

      /* if function exists on the server, fire it first, with a callback */
      /* if function doesn't exist on the server, just send it out directly */
      if (typeof functionName !== 'undefined' && typeof functionName === 'function') {

        fn = (typeof fn == "function") ? fn : global[functionName];
        this.dispatchFunction(functionName, fn.apply(this, functionParams || []));

      } else {

        this.dispatchFunction(functionName, functionParams);

      }

    } else {
      return false;
    }

  };


  /* process request to fire function on the server side and return response */
  var glueFunctionServer = function(theFunction) {
    cons && console.log('glueFunctionServer', theFunction);

    if (theFunction) {

      var functionName = theFunction.functionName;
      var functionParams = theFunction.functionParams;

      if (this.allowedServerFunctions.indexOf(functionName) > -1) {

        this.dispatchHere(functionName, functionParams, function(response){
          return response;

          // to-do: send response back to requester

        });

      } else {
        return false;
      }

    }

  };


  /* helper functions */
  var isRelName = function(nameToCheck) {
    cons && console.log("isRelName", nameToCheck);

    if (typeof nameToCheck === 'string' && /^[a-z0-9-]+$/.test(nameToCheck) === false) {
      return true;
    } else {
      return false;
    }

  };


  var checkStringJSON = function(jsonToTest) {
    cons && console.log("checkStringJSON", jsonToTest);

    if (jsonToTest) {

      try {
        JSON.parse(jsonToTest);
        return true;
      } catch(e) {
        return false;
      }

    } else {
      return false;
    }

  };


  var isRelObject = function(objectToTest) {
    cons && console.log("isRelObject", objectToTest);

    if (typeof objectToTest === 'object') {
      return true;
    } else {
      return checkStringJSON(objectToTest);
    }

  };


  var extend = function(obj, src) {

    for (var key in src) {
        if (src.hasOwnProperty(key)) obj[key] = src[key];
    }

    return obj;

  };


  var generateUUID = function(){

    var d = new Date().getTime();

    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
    });

    return uuid;

  };

};

var exports = module.exports = GlueServer;
